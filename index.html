<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Pocket Groove</title>

<style>
:root{
  --bg:#0b0c10;
  --panel:#12141b;
  --panel2:#0f1117;
  --line:#2a2f3a;
  --txt:#e9ecf1;
  --muted:#9aa3b2;
  --acc:#4aa3ff;
  --good:#55ff9a;
  --warn:#ffd36a;
  --bad:#ff5a6a;
  --radius:18px;
  --shadow:0 10px 30px rgba(0,0,0,.35);
  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }

body{
  margin:0;
  font-family:var(--font);
  background:
    radial-gradient(1200px 800px at 30% -10%, rgba(74,163,255,.20), transparent 60%),
    radial-gradient(900px 700px at 90% 10%, rgba(85,255,154,.12), transparent 55%),
    var(--bg);
  color:var(--txt);
}

.wrap{
  max-width:980px;
  margin:0 auto;
  padding:18px 14px 28px;
}

.topbar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  margin-bottom:12px;
  flex-wrap:wrap;
}

.brand{
  display:flex;
  gap:10px;
  align-items:baseline;
}

.brand h1{
  margin:0;
  font-size:18px;
  font-weight:800;
}

.brand .tag{
  font-size:12px;
  color:var(--muted);
  border:1px solid var(--line);
  padding:4px 8px;
  border-radius:999px;
  background:rgba(255,255,255,.03);
}

.panel{
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
}

.grid{
  display:grid;
  grid-template-columns:1.15fr .85fr;
  gap:12px;
}

@media(max-width:860px){
  .grid{ grid-template-columns:1fr; }
}

/* BUTTONS */
button{
  cursor:pointer;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.04);
  color:var(--txt);
  padding:10px 12px;
  border-radius:14px;
  font-weight:650;
  transition:background .15s, transform .06s;
  user-select:none;
}

button:hover{ background:rgba(255,255,255,.06); }
button:active{ transform:translateY(1px); }
button:disabled{ opacity:.45; cursor:not-allowed; }

.primary{
  background:linear-gradient(180deg, rgba(74,163,255,.22), rgba(74,163,255,.08));
  border-color:rgba(74,163,255,.35);
}

.danger{
  background:linear-gradient(180deg, rgba(255,90,106,.22), rgba(255,90,106,.08));
  border-color:rgba(255,90,106,.35);
}

.ghost{ background:rgba(0,0,0,.18); }
.tiny{ padding:8px 10px; font-size:12px; border-radius:12px; }

.toggleOn{
  border-color:rgba(85,255,154,.45)!important;
  background:linear-gradient(180deg, rgba(85,255,154,.20), rgba(85,255,154,.07))!important;
}

.kbd{
  font-family:ui-monospace, monospace;
  font-size:12px;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.22);
}

.smallNote{
  font-size:12px;
  color:var(--muted);
  line-height:1.35;
}
</style>
</head>
<body>
  <div class="wrap">

    <!-- TOP BAR -->
    <div class="topbar">
      <div class="brand">
        <h1>Pocket Groove</h1>
        <span class="tag">16-step • WebAudio • Sampler + WAV</span>
      </div>

      <div class="btnRow">
        <button id="btnStartAudio" class="primary" type="button">START AUDIO</button>
        <button id="btnPlay" class="primary toggleOff" type="button">PLAY</button>
        <button id="btnStop" class="ghost" type="button">STOP</button>
      </div>
    </div>

    <!-- MAIN GRID -->
    <div class="grid">

      <!-- LEFT PANEL : SEQUENCER -->
      <div class="panel">

        <!-- DISPLAY -->
        <div class="display">
          <div class="displayRow">
            <div class="lcd">
              <div class="pill">BPM <b id="lcdBpm">120</b></div>
              <div class="pill">SWING <b id="lcdSwing">0%</b></div>
              <div class="pill">PATTERN <b id="lcdPat">A</b></div>
              <div class="pill">STEP <b id="lcdStep">1</b></div>
            </div>

            <div class="meter" title="Output level">
              <i id="meterFill"></i>
            </div>
          </div>
        </div>

        <!-- CONTROLS -->
        <div class="controls">

          <!-- BPM -->
          <div class="field" style="margin-top:0;">
            <label>
              <span>Tempo</span>
              <span><span class="kbd" id="bpmVal">120</span></span>
            </label>
            <input id="bpm" type="range" min="60" max="160" value="120" />
          </div>

          <!-- SWING + TOOLS -->
          <div class="sliders">

            <div class="field" style="margin-top:0;">
              <label>
                <span>Swing</span>
                <span><span class="kbd" id="swingVal">0%</span></span>
              </label>
              <input id="swing" type="range" min="0" max="65" value="0" />
            </div>

            <div class="btnRow">
              <button id="btnPattern" class="tiny ghost" type="button">PATTERN A/B</button>
              <button id="btnGroove" class="tiny primary" type="button">GROOVE</button>
              <button id="btnRandom" class="tiny" type="button">RANDOM</button>
              <button id="btnClear" class="tiny danger" type="button">CLEAR</button>
            </div>

          </div>
        </div>

        <!-- SEQUENCER GRID -->
        <div class="seq">
          <div class="tracks" id="tracks"></div>

          <div class="smallNote">
            Suggerimento: premi <b>START AUDIO</b>, poi <b>PLAY</b>.  
            Tocca gli step per programmare il groove.
          </div>
        </div>

      </div>
            <!-- RIGHT PANEL -->
      <div class="panel">
        <div class="side">

          <!-- PRESET -->
          <div class="box">
            <h3>Preset</h3>
            <div class="row">
              <div class="left">
                <button id="btnSave" class="tiny primary" type="button">SAVE</button>
                <button id="btnLoad" class="tiny" type="button">LOAD</button>
                <button id="btnReset" class="tiny ghost" type="button">RESET</button>
              </div>
              <div class="left">
                <span class="kbd">Space</span>
                <span class="smallNote">Play / Pause</span>
              </div>
            </div>
            <div class="smallNote" id="presetStatus">Nessun preset salvato.</div>
          </div>

          <!-- RECORD WAV -->
          <div class="box">
            <h3>Record WAV</h3>
            <div class="row">
              <div class="left">
                <button id="btnRec" class="tiny primary" type="button">REC</button>
                <button id="btnRecStop" class="tiny danger" type="button" disabled>STOP</button>
                <button id="btnRecSave" class="tiny" type="button" disabled>SAVE WAV</button>
              </div>
              <div class="left">
                <span class="kbd" id="recTimer">00:00</span>
              </div>
            </div>
            <div class="smallNote" id="recStatus">
              Pronto. Premi REC per registrare l'output (post-FX).
            </div>
            <a id="wavDownload" style="display:none;"></a>
          </div>

          <!-- FX XY -->
          <div class="box">
            <h3>FX</h3>
            <div class="row">
              <div class="left">
                <button id="btnHoldFx" class="tiny" type="button">HOLD FX</button>
                <button id="btnFxReset" class="tiny ghost" type="button">RESET</button>
              </div>
              <div class="left">
                <span class="kbd">Drag</span>
                <span class="smallNote">XY</span>
              </div>
            </div>

            <div id="fxPad"
              style="margin-top:10px; height:190px;
                     border-radius:16px;
                     border:1px solid rgba(255,255,255,.10);
                     background:rgba(0,0,0,.25);
                     position:relative;
                     overflow:hidden;
                     touch-action:none;">

              <div id="fxDot"
                style="width:16px;height:16px;
                       border-radius:50%;
                       background:rgba(74,163,255,.95);
                       position:absolute;
                       left:50%;top:50%;
                       transform:translate(-50%,-50%);
                       box-shadow:0 0 0 6px rgba(74,163,255,.15);">
              </div>

              <div style="position:absolute;left:10px;top:10px;font-size:12px;color:var(--muted);">
                X: Filter
              </div>
              <div style="position:absolute;right:10px;bottom:10px;font-size:12px;color:var(--muted);text-align:right;">
                Y: Stutter
              </div>
            </div>

            <div class="smallNote" id="fxReadout">Filter: 50% • Stutter: Off</div>
          </div>

          <!-- BASS -->
          <div class="box">
            <h3>Bass</h3>
            <label for="bassNote" class="smallNote" style="display:block;margin-bottom:8px;">
              Nota
            </label>
            <select id="bassNote">
              <option value="55">A1 (55Hz)</option>
              <option value="61.735">B1 (61.7Hz)</option>
              <option value="65.406">C2 (65.4Hz)</option>
              <option value="73.416">D2 (73.4Hz)</option>
              <option value="82.407" selected>E2 (82.4Hz)</option>
              <option value="98">G2 (98Hz)</option>
              <option value="110">A2 (110Hz)</option>
            </select>
            <div class="smallNote">
              Bass mono “una nota”: cambia la nota e crea pattern ipnotici.
            </div>
          </div>

          <!-- SAMPLER MIC -->
          <div class="box">
            <h3>Sampler (Mic)</h3>

            <div class="row">
              <div class="left">
                <button id="btnMicArm" class="tiny" type="button">ARM MIC</button>
                <button id="btnMicRec" class="tiny primary" type="button" disabled>REC</button>
                <button id="btnMicStop" class="tiny danger" type="button" disabled>STOP</button>
              </div>
              <div class="left">
                <span class="kbd" id="micTimer">00:00</span>
              </div>
            </div>

            <div class="row" style="margin-top:10px;">
              <div class="left">
                <button id="btnUseSample" class="tiny" type="button" disabled>USE AS SAMPLE</button>
                <button id="btnClearSample" class="tiny ghost" type="button" disabled>CLEAR</button>
              </div>
              <div class="left">
                <label class="smallNote" style="display:flex;gap:6px;align-items:center;">
                  <input id="chkMonitor" type="checkbox" />
                  Monitor
                </label>
              </div>
            </div>

            <div class="field">
              <label>
                <span>Start Trim</span>
                <span><span class="kbd" id="trimVal">0%</span></span>
              </label>
              <input id="trimStart" type="range" min="0" max="80" value="0" />
            </div>

            <div class="field">
              <label>
                <span>Pitch</span>
                <span><span class="kbd" id="pitchVal">0 st</span></span>
              </label>
              <input id="pitchSemi" type="range" min="-12" max="12" value="0" />
            </div>

            <div class="field">
              <label>
                <span>Filter</span>
                <span><span class="kbd" id="filtVal">100%</span></span>
              </label>
              <input id="sampleFilter" type="range" min="0" max="100" value="100" />
            </div>

            <div class="field">
              <label>
                <span>Decay</span>
                <span><span class="kbd" id="decayVal">120 ms</span></span>
              </label>
              <input id="sampleDecay" type="range" min="40" max="600" value="120" />
            </div>

            <div class="smallNote" id="micStatus">
              Premi ARM MIC, registra, poi USE AS SAMPLE.
            </div>
          </div>

          <!-- ABOUT -->
          <div class="box">
            <h3>About</h3>
            <div class="smallNote">
              Pocket Groove • WebAudio groovebox.<br/>
              FX XY, Sampler Mic, Groove presets, Export WAV.
            </div>
          </div>

          <div class="footer smallNote">
            Repo: <b>pocket-groove</b>
          </div>

        </div>
      </div>

    </div> <!-- end grid -->
  </div> <!-- end wrap -->
  <script>
(() => {
  "use strict";

  // ============
  // STATE / DATA
  // ============
  const TRACKS = [
    { id:"kick",   name:"KICK",   cls:""   },
    { id:"snare",  name:"SNARE",  cls:"sn" },
    { id:"hat",    name:"HAT",    cls:"hh" },
    { id:"bass",   name:"BASS",   cls:"bs" },
    { id:"sample", name:"SAMPLE", cls:""   },
  ];

  // pattern A/B
  let pattern = {
    A: { kick:new Array(16).fill(false), snare:new Array(16).fill(false), hat:new Array(16).fill(false), bass:new Array(16).fill(false), sample:new Array(16).fill(false) },
    B: { kick:new Array(16).fill(false), snare:new Array(16).fill(false), hat:new Array(16).fill(false), bass:new Array(16).fill(false), sample:new Array(16).fill(false) },
  };

  // starter groove (sample vuoto)
  pattern.A.kick   = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0].map(Boolean);
  pattern.A.snare  = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0].map(Boolean);
  pattern.A.hat    = [0,1,0,1, 0,1,0,1, 0,1,0,1, 0,1,0,1].map(Boolean);
  pattern.A.bass   = [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,1,0,0].map(Boolean);
  pattern.A.sample = new Array(16).fill(false);

  let currentPat = "A";
  let stepIndex = 0;
  let isPlaying = false;

  // timing
  let bpm = 120;
  let swing = 0; // 0..0.65
  let nextStepTime = 0;

  // scheduler
  const lookaheadMs = 25;
  const scheduleAheadSec = 0.12;
  let timerId = null;

  // ============
  // AUDIO STATE
  // ============
  let audioCtx = null;
  let master = null;
  let analyser = null;
  let started = false;

  // bass note
  let bassHz = 82.407;

  // FX state
  let holdFx = false;
  let fxX = 0.5; // 0..1 (filter)
  let fxY = 0.0; // 0..1 (stutter)
  let stutterTimer = null;
  let stutterCurrentHz = 0;

  // =================
  // UI REFERENCES
  // =================
  const elTracks = document.getElementById("tracks");

  const btnStartAudio = document.getElementById("btnStartAudio");
  const btnPlay = document.getElementById("btnPlay");
  const btnStop = document.getElementById("btnStop");

  const bpmSlider = document.getElementById("bpm");
  const swingSlider = document.getElementById("swing");

  const lcdBpm = document.getElementById("lcdBpm");
  const lcdSwing = document.getElementById("lcdSwing");
  const lcdPat = document.getElementById("lcdPat");
  const lcdStep = document.getElementById("lcdStep");
  const meterFill = document.getElementById("meterFill");

  const bpmVal = document.getElementById("bpmVal");
  const swingVal = document.getElementById("swingVal");

  const btnPattern = document.getElementById("btnPattern");
  const btnGroove  = document.getElementById("btnGroove");
  const btnClear = document.getElementById("btnClear");
  const btnRandom = document.getElementById("btnRandom");

  const btnSave = document.getElementById("btnSave");
  const btnLoad = document.getElementById("btnLoad");
  const btnReset = document.getElementById("btnReset");
  const presetStatus = document.getElementById("presetStatus");

  const bassNoteSel = document.getElementById("bassNote");

  // WAV REC refs
  const btnRec = document.getElementById("btnRec");
  const btnRecStop = document.getElementById("btnRecStop");
  const btnRecSave = document.getElementById("btnRecSave");
  const recStatus = document.getElementById("recStatus");
  const recTimer = document.getElementById("recTimer");
  const wavDownload = document.getElementById("wavDownload");

  // FX refs
  const btnHoldFx = document.getElementById("btnHoldFx");
  const btnFxReset = document.getElementById("btnFxReset");
  const fxPad = document.getElementById("fxPad");
  const fxDot = document.getElementById("fxDot");
  const fxReadout = document.getElementById("fxReadout");

  // =================
  // UTILS
  // =================
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function mmss(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = String(Math.floor(sec/60)).padStart(2,"0");
    const s = String(sec%60).padStart(2,"0");
    return `${m}:${s}`;
  }

  // ---------- Bass selector ----------
  if (bassNoteSel) {
    bassNoteSel.addEventListener("change", () => {
      bassHz = Number(bassNoteSel.value) || bassHz;
    });
  }
    // ==========================
  // FX XY PAD
  // ==========================
  function setFxDot(){
    if(!fxPad || !fxDot) return;
    fxDot.style.left = (fxX * 100) + "%";
    fxDot.style.top  = ((1 - fxY) * 100) + "%";
  }

  function fxFilterFreqFromX(x){
    const min = 200, max = 18000;
    const k = Math.pow(clamp01(x), 2.2);
    return min + (max - min) * k;
  }

  function stopStutter(){
    const fx = window.__PG_FX__;
    if(fx && audioCtx){
      fx.stutterGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.01);
    }
    if(stutterTimer){
      clearInterval(stutterTimer);
      stutterTimer = null;
    }
    stutterCurrentHz = 0;
  }

  function startStutter(rateHz){
    const fx = window.__PG_FX__;
    if(!fx || !audioCtx) return;

    const hz = Math.max(2, Math.min(30, rateHz));
    if(stutterTimer && Math.abs(hz - stutterCurrentHz) < 0.5) return;

    stopStutter();
    stutterCurrentHz = hz;

    let on = true;
    stutterTimer = setInterval(() => {
      fx.stutterGain.gain.setTargetAtTime(on ? 1.0 : 0.0, audioCtx.currentTime, 0.002);
      on = !on;
    }, Math.max(25, 1000 / hz));
  }

  function updateFx(){
    const fx = window.__PG_FX__;
    if(!fx || !started || !audioCtx) return;

    fx.filter.frequency.setTargetAtTime(
      fxFilterFreqFromX(fxX),
      audioCtx.currentTime,
      0.01
    );

    if(fxY < 0.05){
      stopStutter();
      fxReadout.textContent = `Filter: ${Math.round(fxX*100)}% • Stutter: Off`;
    }else{
      const hz = 2 + fxY * 18;
      startStutter(hz);
      fxReadout.textContent = `Filter: ${Math.round(fxX*100)}% • Stutter: ${Math.round(hz)} Hz`;
    }

    setFxDot();
  }

  function setFxFromPointer(x, y){
    const r = fxPad.getBoundingClientRect();
    fxX = clamp01((x - r.left) / r.width);
    fxY = clamp01(1 - (y - r.top) / r.height);
  }

  if(fxPad){
    fxPad.addEventListener("pointerdown", e => {
      if(!started) return;
      fxPad.setPointerCapture(e.pointerId);
      holdFx = true;
      btnHoldFx.classList.add("toggleOn");
      setFxFromPointer(e.clientX, e.clientY);
      updateFx();
    });

    fxPad.addEventListener("pointermove", e => {
      if(!holdFx) return;
      setFxFromPointer(e.clientX, e.clientY);
      updateFx();
    });

    fxPad.addEventListener("pointerup", () => {
      holdFx = false;
      btnHoldFx.classList.remove("toggleOn");
      stopStutter();
      updateFx();
    });
  }

  btnHoldFx?.addEventListener("click", () => {
    if(!started) return;
    holdFx = !holdFx;
    btnHoldFx.classList.toggle("toggleOn", holdFx);
    if(!holdFx) stopStutter();
  });

  btnFxReset?.addEventListener("click", () => {
    fxX = 0.5;
    fxY = 0.0;
    stopStutter();
    updateFx();
    fxReadout.textContent = "Filter: 50% • Stutter: Off";
  });

  // ==========================
  // AUDIO ENGINE + FX CHAIN
  // ==========================
  function ensureAudio(){
    if(audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: "interactive"
    });

    master = audioCtx.createGain();
    master.gain.value = 0.9;

    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 18000;
    filter.Q.value = 0.7;

    const stutterGain = audioCtx.createGain();
    stutterGain.gain.value = 1.0;

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;

    master.connect(filter);
    filter.connect(stutterGain);
    stutterGain.connect(analyser);
    analyser.connect(audioCtx.destination);

    window.__PG_FX__ = { filter, stutterGain };
    window.__PG_REC_SRC__ = stutterGain;

    setFxDot();
  }

  async function startAudio(){
    ensureAudio();
    if(audioCtx.state !== "running"){
      await audioCtx.resume();
    }
    started = true;
    btnStartAudio.textContent = "AUDIO OK";
    btnStartAudio.classList.add("toggleOn");
    btnStartAudio.disabled = true;
    updateFx();
  }
    // =========================
  // RECORD WAV (output post-FX)
  // =========================
  let recNode = null;
  let recZero = null;
  let recChunksL = [];
  let recChunksR = [];
  let recLength = 0;
  let recSampleRate = 44100;
  let recRunning = false;
  let recStartTs = 0;
  let recTimerId = null;

  function formatMMSS(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = String(Math.floor(sec / 60)).padStart(2, "0");
    const s = String(sec % 60).padStart(2, "0");
    return `${m}:${s}`;
  }

  function updateRecTimer(){
    if(!recTimer) return;
    const sec = (performance.now() - recStartTs) / 1000;
    recTimer.textContent = formatMMSS(sec);
  }

  function recorderInit(){
    if(!started || !audioCtx){
      recStatus && (recStatus.textContent = "Tocca START AUDIO prima.");
      return false;
    }
    const src = window.__PG_REC_SRC__;
    if(!src){
      recStatus && (recStatus.textContent = "Sorgente REC non pronta.");
      return false;
    }

    recSampleRate = audioCtx.sampleRate;
    recChunksL = [];
    recChunksR = [];
    recLength = 0;

    // Nota: ScriptProcessor è deprecato ma ancora supportato (perfetto per prototipi / GitHub Pages)
    const bufferSize = 4096;
    recNode = audioCtx.createScriptProcessor(bufferSize, 2, 2);

    // nodo “zero” per tenerlo vivo senza sommare audio
    recZero = audioCtx.createGain();
    recZero.gain.value = 0.0;
    recNode.connect(recZero);
    recZero.connect(audioCtx.destination);

    // tap post-FX (stutterGain)
    src.connect(recNode);

    recNode.onaudioprocess = (e) => {
      if(!recRunning) return;
      const input = e.inputBuffer;
      const ch = input.numberOfChannels;
      const inL = input.getChannelData(0);
      const inR = (ch > 1) ? input.getChannelData(1) : inL;

      recChunksL.push(new Float32Array(inL));
      recChunksR.push(new Float32Array(inR));
      recLength += inL.length;
    };

    return true;
  }

  function mergeFloat32(chunks, totalLength){
    const out = new Float32Array(totalLength);
    let offset = 0;
    for(const c of chunks){
      out.set(c, offset);
      offset += c.length;
    }
    return out;
  }

  function interleaveStereo(left, right){
    const len = Math.min(left.length, right.length);
    const out = new Float32Array(len * 2);
    let j = 0;
    for(let i=0;i<len;i++){
      out[j++] = left[i];
      out[j++] = right[i];
    }
    return out;
  }

  function writeString(view, offset, str){
    for(let i=0;i<str.length;i++){
      view.setUint8(offset + i, str.charCodeAt(i));
    }
  }

  function floatTo16BitPCM(view, offset, input){
    for(let i=0;i<input.length;i++, offset+=2){
      let s = Math.max(-1, Math.min(1, input[i]));
      s = s < 0 ? s * 0x8000 : s * 0x7fff;
      view.setInt16(offset, s, true);
    }
  }

  function encodeWAV(interleaved, sampleRate){
    const numChannels = 2;
    const bytesPerSample = 2;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = sampleRate * blockAlign;
    const dataSize = interleaved.length * bytesPerSample;

    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);

    writeString(view, 0, "RIFF");
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, "WAVE");
    writeString(view, 12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); // PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, 16, true); // 16-bit
    writeString(view, 36, "data");
    view.setUint32(40, dataSize, true);

    floatTo16BitPCM(view, 44, interleaved);
    return new Blob([view], { type:"audio/wav" });
  }

  function recStart(){
    if(recRunning) return;
    if(!recorderInit()) return;

    recRunning = true;
    recStartTs = performance.now();
    recTimer && (recTimer.textContent = "00:00");
    recTimerId = setInterval(updateRecTimer, 250);

    btnRec && (btnRec.disabled = true);
    btnRecStop && (btnRecStop.disabled = false);
    btnRecSave && (btnRecSave.disabled = true);
    wavDownload && (wavDownload.style.display = "none");

    recStatus && (recStatus.textContent = "REC in corso… registra l'output (post-FX).");
  }

  function recStop(){
    if(!recRunning) return;
    recRunning = false;

    if(recTimerId){
      clearInterval(recTimerId);
      recTimerId = null;
    }
    updateRecTimer();

    // stacca tap
    try{
      const src = window.__PG_REC_SRC__;
      if(src && recNode) src.disconnect(recNode);
    }catch{}

    try{ recNode && recNode.disconnect(); }catch{}
    try{ recZero && recZero.disconnect(); }catch{}
    recNode = null;
    recZero = null;

    btnRec && (btnRec.disabled = false);
    btnRecStop && (btnRecStop.disabled = true);
    btnRecSave && (btnRecSave.disabled = (recLength === 0));

    recStatus && (recStatus.textContent = recLength ? "STOP. Premi SAVE WAV." : "STOP. Nessun audio registrato.");
  }

  function recSave(){
    if(recLength === 0) return;

    const left = mergeFloat32(recChunksL, recLength);
    const right = mergeFloat32(recChunksR, recLength);

    const interleaved = interleaveStereo(left, right);
    const wavBlob = encodeWAV(interleaved, recSampleRate);

    const url = URL.createObjectURL(wavBlob);
    const ts = new Date();
    const pad = (n)=>String(n).padStart(2,"0");
    const name =
      `pocket-groove_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_` +
      `${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.wav`;

    if(wavDownload){
      wavDownload.href = url;
      wavDownload.download = name;
      wavDownload.textContent = "Download WAV";
      wavDownload.style.display = "inline-block";
    }
    recStatus && (recStatus.textContent = "WAV pronto. Premi Download WAV.");
  }

  btnRec?.addEventListener("click", recStart);
  btnRecStop?.addEventListener("click", recStop);
  btnRecSave?.addEventListener("click", recSave);
    // =====================
  // Sampler (Mic) - 1 slot
  // =====================
  const btnMicArm   = document.getElementById("btnMicArm");
  const btnMicRec   = document.getElementById("btnMicRec");
  const btnMicStop  = document.getElementById("btnMicStop");
  const btnUseSample= document.getElementById("btnUseSample");
  const btnClearSample = document.getElementById("btnClearSample");
  const micStatus   = document.getElementById("micStatus");
  const micTimer    = document.getElementById("micTimer");
  const chkMonitor  = document.getElementById("chkMonitor");

  const trimStartEl = document.getElementById("trimStart");
  const pitchSemiEl = document.getElementById("pitchSemi");
  const sampleFilterEl = document.getElementById("sampleFilter");
  const sampleDecayEl  = document.getElementById("sampleDecay");
  const trimVal = document.getElementById("trimVal");
  const pitchVal = document.getElementById("pitchVal");
  const filtVal  = document.getElementById("filtVal");
  const decayVal = document.getElementById("decayVal");

  let micStream = null;
  let micSrc = null;
  let micWorklet = null;
  let micMonitorGain = null;

  let micArmed = false;
  let micRecording = false;
  let micStartTs = 0;
  let micTimerId = null;

  // recorded PCM mono
  let micRecChunks = [];
  let micRecLen = 0;
  let micRecSampleRate = 44100;

  // sample slot
  let sampleBuf = null;
  let sampleReady = false;

  // sample params
  let trimStartPct = 0;        // 0..0.8
  let pitchSemi = 0;           // -12..12
  let sampleFilterPct = 1.0;   // 0..1
  let sampleDecayMs = 120;

  function mmss(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = String(Math.floor(sec/60)).padStart(2,"0");
    const s = String(sec%60).padStart(2,"0");
    return `${m}:${s}`;
  }

  function setSamplerUIState(){
    btnMicArm && btnMicArm.classList.toggle("toggleOn", micArmed);
    btnMicRec && (btnMicRec.disabled = !micArmed || micRecording);
    btnMicStop && (btnMicStop.disabled = !micRecording);
    btnUseSample && (btnUseSample.disabled = (micRecLen === 0) || micRecording);
    btnClearSample && (btnClearSample.disabled = !sampleReady);
  }

  function updateSamplerLabels(){
    trimVal && (trimVal.textContent = `${Math.round(trimStartPct*100)}%`);
    pitchVal && (pitchVal.textContent = `${pitchSemi} st`);
    filtVal  && (filtVal.textContent  = `${Math.round(sampleFilterPct*100)}%`);
    decayVal && (decayVal.textContent = `${sampleDecayMs} ms`);
  }

  trimStartEl?.addEventListener("input", () => {
    trimStartPct = (Number(trimStartEl.value) || 0) / 100;
    updateSamplerLabels();
  });
  pitchSemiEl?.addEventListener("input", () => {
    pitchSemi = Number(pitchSemiEl.value) || 0;
    updateSamplerLabels();
  });
  sampleFilterEl?.addEventListener("input", () => {
    sampleFilterPct = (Number(sampleFilterEl.value) || 100) / 100;
    updateSamplerLabels();
  });
  sampleDecayEl?.addEventListener("input", () => {
    sampleDecayMs = Number(sampleDecayEl.value) || 120;
    updateSamplerLabels();
  });

  updateSamplerLabels();

  // --------------------------
  // Mic Worklet (load once)
  // --------------------------
  let micWorkletLoaded = false;

  async function ensureMicWorklet(){
    if(micWorkletLoaded) return;

    ensureAudio();
    if(!audioCtx) return;

    const code = `
      class MicTapProcessor extends AudioWorkletProcessor {
        process(inputs) {
          const input = inputs[0];
          if (input && input[0]) {
            // invio mono (canale 0)
            this.port.postMessage(input[0]);
          }
          return true;
        }
      }
      registerProcessor('mic-tap', MicTapProcessor);
    `;

    const blob = new Blob([code], { type:"application/javascript" });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);

    micWorkletLoaded = true;
  }

  // --------------------------
  // Arm mic + monitor
  // --------------------------
  let monitorListenerBound = false;

  async function armMic(){
    try{
      await startAudio(); // gesto utente (Safari iOS)

      if(!navigator.mediaDevices?.getUserMedia){
        micStatus && (micStatus.textContent = "getUserMedia non disponibile su questo browser.");
        return;
      }

      if(!micStream){
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: false
          }
        });
      }

      await ensureMicWorklet();

      // crea catena mic -> worklet (tap) + opzionale monitor
      micSrc = audioCtx.createMediaStreamSource(micStream);
      micWorklet = new AudioWorkletNode(audioCtx, "mic-tap", {
        numberOfInputs: 1,
        numberOfOutputs: 0
      });

      micMonitorGain = audioCtx.createGain();
      micMonitorGain.gain.value = chkMonitor?.checked ? 0.8 : 0.0;

      // ricezione chunk dal worklet
      micWorklet.port.onmessage = (e) => {
        if(!micRecording) return;
        const chunk = e.data; // Float32Array
        if(!chunk || !chunk.length) return;
        micRecChunks.push(new Float32Array(chunk));
        micRecLen += chunk.length;
      };

      // connessioni
      micSrc.connect(micWorklet);

      // monitor nel master (quindi passa anche negli FX / REC)
      micSrc.connect(micMonitorGain);
      micMonitorGain.connect(master);

      // bind una sola volta
      if(chkMonitor && !monitorListenerBound){
        chkMonitor.addEventListener("change", () => {
          if(!micMonitorGain) return;
          micMonitorGain.gain.value = chkMonitor.checked ? 0.8 : 0.0;
        });
        monitorListenerBound = true;
      }

      micRecSampleRate = audioCtx.sampleRate;
      micArmed = true;
      micStatus && (micStatus.textContent = "Mic pronto. Premi REC (consigliato: 1–5 secondi).");
      setSamplerUIState();
    }catch(err){
      console.error(err);
      micArmed = false;
      micStatus && (micStatus.textContent = "Permesso microfono negato o errore.");
      setSamplerUIState();
    }
  }

  // --------------------------
  // Mic record
  // --------------------------
  function micRecStart(){
    if(!micArmed || micRecording) return;

    micRecChunks = [];
    micRecLen = 0;

    micRecording = true;
    micStartTs = performance.now();

    micTimer && (micTimer.textContent = "00:00");
    micTimerId = setInterval(() => {
      micTimer && (micTimer.textContent = mmss((performance.now() - micStartTs)/1000));
    }, 200);

    micStatus && (micStatus.textContent = "REC… fai un suono/voce, poi STOP.");
    setSamplerUIState();
  }

  function micRecStop(){
    if(!micRecording) return;

    micRecording = false;
    if(micTimerId){
      clearInterval(micTimerId);
      micTimerId = null;
    }

    micStatus && (micStatus.textContent = micRecLen ? "STOP. Premi USE AS SAMPLE." : "STOP. Nessun audio registrato.");
    setSamplerUIState();
  }

  // --------------------------
  // Buffer utils + Normalize
  // --------------------------
  function mergeMono(chunks, total){
    const out = new Float32Array(total);
    let off = 0;
    for(const c of chunks){
      out.set(c, off);
      off += c.length;
    }
    return out;
  }

  function normalizeInPlace(buf){
    let peak = 0;
    for(let i=0;i<buf.length;i++){
      const a = Math.abs(buf[i]);
      if(a > peak) peak = a;
    }
    const gain = peak > 0 ? (0.95 / peak) : 1;
    for(let i=0;i<buf.length;i++){
      buf[i] *= gain;
    }
    return { peak, gain };
  }

  // --------------------------
  // Use as sample (FIXED)
  // --------------------------
  function useAsSample(){
    if(micRecLen === 0) return;
    ensureAudio();
    if(!audioCtx) return;

    const mono = mergeMono(micRecChunks, micRecLen);

    // NORMALIZE (essenziale per voce/registrazioni deboli)
    normalizeInPlace(mono);

    const buf = audioCtx.createBuffer(1, mono.length, micRecSampleRate);
    buf.copyToChannel(mono, 0, 0);

    sampleBuf = buf;
    sampleReady = true;

    micStatus && (micStatus.textContent = "Sample caricato ✔ Ora attiva gli step SAMPLE.");
    setSamplerUIState();
  }

  function clearSample(){
    sampleBuf = null;
    sampleReady = false;
    micStatus && (micStatus.textContent = "Sample svuotato.");
    setSamplerUIState();
  }

  // --------------------------
  // Trigger sample
  // --------------------------
  function triggerSample(when){
    if(!sampleReady || !sampleBuf || !audioCtx) return;

    const src = audioCtx.createBufferSource();
    src.buffer = sampleBuf;

    // pitch (semitoni)
    const rate = Math.pow(2, pitchSemi / 12);
    src.playbackRate.setValueAtTime(rate, when);

    // gain envelope
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, when);
    g.gain.exponentialRampToValueAtTime(0.95, when + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, when + (sampleDecayMs/1000));

    // filter
    const f = audioCtx.createBiquadFilter();
    f.type = "lowpass";
    const minF = 300, maxF = 18000;
    const cutoff = minF + (maxF - minF) * Math.pow(sampleFilterPct, 2.1);
    f.frequency.setValueAtTime(cutoff, when);
    f.Q.value = 0.8;

    src.connect(f);
    f.connect(g);
    g.connect(master);

    // trim start + max duration
    const startOffset = sampleBuf.duration * trimStartPct;
    const maxDur = Math.min(2.0, Math.max(0.05, sampleBuf.duration - startOffset));

    src.start(when, startOffset, maxDur);
    src.stop(when + maxDur + 0.05);
  }

  // --------------------------
  // Buttons
  // --------------------------
  btnMicArm?.addEventListener("click", armMic);
  btnMicRec?.addEventListener("click", micRecStart);
  btnMicStop?.addEventListener("click", micRecStop);
  btnUseSample?.addEventListener("click", useAsSample);
  btnClearSample?.addEventListener("click", clearSample);

  setSamplerUIState();
    // ==========================
  // SOUND GENERATORS
  // ==========================

  function triggerKick(when){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = "sine";
    o.frequency.setValueAtTime(150, when);
    o.frequency.exponentialRampToValueAtTime(55, when + 0.08);

    g.gain.setValueAtTime(0.0001, when);
    g.gain.exponentialRampToValueAtTime(1.0, when + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.12);

    o.connect(g);
    g.connect(master);

    o.start(when);
    o.stop(when + 0.14);
  }

  function triggerSnare(when){
    const noise = makeNoiseBuffer();
    const n = audioCtx.createBufferSource();
    n.buffer = noise;

    const hp = audioCtx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1200;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, when);
    g.gain.exponentialRampToValueAtTime(0.8, when + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.14);

    const o = audioCtx.createOscillator();
    o.type = "triangle";
    o.frequency.setValueAtTime(220, when);

    const og = audioCtx.createGain();
    og.gain.setValueAtTime(0.0001, when);
    og.gain.exponentialRampToValueAtTime(0.35, when + 0.004);
    og.gain.exponentialRampToValueAtTime(0.0001, when + 0.09);

    n.connect(hp);
    hp.connect(g);

    o.connect(og);
    og.connect(g);

    g.connect(master);

    n.start(when);
    n.stop(when + 0.16);
    o.start(when);
    o.stop(when + 0.12);
  }

  function triggerHat(when){
    const noise = makeNoiseBuffer();
    const n = audioCtx.createBufferSource();
    n.buffer = noise;

    const bp = audioCtx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 8000;
    bp.Q.value = 6;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, when);
    g.gain.exponentialRampToValueAtTime(0.35, when + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.05);

    n.connect(bp);
    bp.connect(g);
    g.connect(master);

    n.start(when);
    n.stop(when + 0.06);
  }

  function triggerBass(when){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const f = audioCtx.createBiquadFilter();

    o.type = "square";
    o.frequency.setValueAtTime(bassHz, when);

    f.type = "lowpass";
    f.frequency.setValueAtTime(600, when);
    f.Q.value = 0.8;

    g.gain.setValueAtTime(0.0001, when);
    g.gain.exponentialRampToValueAtTime(0.55, when + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.16);

    o.connect(f);
    f.connect(g);
    g.connect(master);

    o.start(when);
    o.stop(when + 0.18);
  }

  // ==========================
  // NOISE BUFFER (cached)
  // ==========================
  let _noiseBuffer = null;

  function makeNoiseBuffer(){
    if(_noiseBuffer) return _noiseBuffer;

    const length = audioCtx.sampleRate * 0.5;
    const buffer = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);

    for(let i = 0; i < length; i++){
      data[i] = Math.random() * 2 - 1;
    }

    _noiseBuffer = buffer;
    return buffer;
  }

  // ==========================
  // TRACK DISPATCHER
  // ==========================
  function triggerTrack(trackId, when){
    if(!audioCtx) return;

    switch(trackId){
      case "kick":
        triggerKick(when);
        break;

      case "snare":
        triggerSnare(when);
        break;

      case "hat":
        triggerHat(when);
        break;

      case "bass":
        triggerBass(when);
        break;

      case "sample":
        triggerSample(when);
        break;
    }
  }
    // ==========================
  // SEQUENCER TIMING
  // ==========================
  function secondsPerStep(){
    return 60 / bpm / 4; // 16th
  }

  function swingOffset(step){
    return (step % 2 === 1) ? secondsPerStep() * swing : 0;
  }

  function scheduleStep(step, time){
    const pat = pattern[currentPat];

    if(pat.kick[step])   triggerKick(time);
    if(pat.snare[step])  triggerSnare(time);
    if(pat.hat[step])    triggerHat(time);
    if(pat.bass[step])   triggerBass(time);
    if(pat.sample[step]) triggerSample(time);

    const uiDelay = Math.max(0, (time - audioCtx.currentTime) * 1000);
    setTimeout(() => flashPlayhead(step), uiDelay);
  }

  function scheduler(){
    if(!isPlaying) return;

    while(nextStepTime < audioCtx.currentTime + scheduleAheadSec){
      const offset = swingOffset(stepIndex);
      scheduleStep(stepIndex, nextStepTime + offset);
      stepIndex = (stepIndex + 1) % 16;
      nextStepTime += secondsPerStep();
    }
  }

  function startSequencer(){
    ensureAudio();
    if(!started || isPlaying) return;

    isPlaying = true;
    btnPlay.textContent = "PAUSE";
    btnPlay.classList.add("toggleOn");

    stepIndex = 0;
    nextStepTime = audioCtx.currentTime + 0.06;
    timerId = setInterval(scheduler, lookaheadMs);
  }

  function stopSequencer(){
    isPlaying = false;
    btnPlay.textContent = "PLAY";
    btnPlay.classList.remove("toggleOn");

    if(timerId){
      clearInterval(timerId);
      timerId = null;
    }
    stepIndex = 0;
    lcdStep.textContent = "1";
  }

  function togglePlay(){
    if(isPlaying) stopSequencer();
    else startSequencer();
  }

  // ==========================
  // METER
  // ==========================
  const meterData = new Uint8Array(1024);

  function meterLoop(){
    if(analyser){
      analyser.getByteTimeDomainData(meterData);
      let sum = 0;
      for(let i=0;i<meterData.length;i++){
        const v = (meterData[i] - 128) / 128;
        sum += v * v;
      }
      const rms = Math.sqrt(sum / meterData.length);
      meterFill.style.width = Math.min(100, rms * 300) + "%";
    }
    requestAnimationFrame(meterLoop);
  }

  // ==========================
  // GROOVE BANK
  // ==========================
  let grooveIndex = -1;

  const GROOVES = [
    { name:"4x4 Minimal",
      kick:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      snare:[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      hat:[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
      bass:[1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0]
    },
    { name:"Electro",
      kick:[1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0],
      snare:[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
      hat:[0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],
      bass:[1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0]
    }
  ];

  function applyGroove(g){
    const pat = pattern[currentPat];
    pat.kick = g.kick.map(Boolean);
    pat.snare = g.snare.map(Boolean);
    pat.hat = g.hat.map(Boolean);
    pat.bass = g.bass.map(Boolean);
    pat.sample = new Array(16).fill(false);
    renderSteps();
    presetStatus.textContent = "Groove: " + g.name;
  }

  function nextGroove(){
    grooveIndex = (grooveIndex + 1) % GROOVES.length;
    applyGroove(GROOVES[grooveIndex]);
  }

  // ==========================
  // PRESET SAVE / LOAD
  // ==========================
  const LS_KEY = "pocket-groove-final";

  function savePreset(){
    localStorage.setItem(LS_KEY, JSON.stringify({
      pattern, bpm, swing, bassHz,
      trimStartPct, pitchSemi, sampleFilterPct, sampleDecayMs
    }));
    presetStatus.textContent = "Preset salvato ✔";
  }

  function loadPreset(){
    const raw = localStorage.getItem(LS_KEY);
    if(!raw){ presetStatus.textContent = "Nessun preset."; return; }

    const d = JSON.parse(raw);
    pattern = d.pattern;
    bpm = d.bpm;
    swing = d.swing;
    bassHz = d.bassHz;
    trimStartPct = d.trimStartPct;
    pitchSemi = d.pitchSemi;
    sampleFilterPct = d.sampleFilterPct;
    sampleDecayMs = d.sampleDecayMs;

    bpmSlider.value = bpm;
    swingSlider.value = swing * 100;
    bassNoteSel.value = bassHz;

    updateSamplerLabels();
    syncLCD();
    renderSteps();

    presetStatus.textContent = "Preset caricato ✔";
  }

  function resetPreset(){
    localStorage.removeItem(LS_KEY);
    presetStatus.textContent = "Preset eliminato.";
  }

  // ==========================
  // UI EVENTS
  // ==========================
  btnStartAudio.addEventListener("click", startAudio);
  btnPlay.addEventListener("click", togglePlay);
  btnStop.addEventListener("click", stopSequencer);

  btnGroove.addEventListener("click", nextGroove);
  btnSave.addEventListener("click", savePreset);
  btnLoad.addEventListener("click", loadPreset);
  btnReset.addEventListener("click", resetPreset);

  bpmSlider.addEventListener("input", () => {
    bpm = Number(bpmSlider.value);
    syncLCD();
  });

  swingSlider.addEventListener("input", () => {
    swing = Number(swingSlider.value) / 100;
    syncLCD();
  });

  window.addEventListener("keydown", e => {
    if(e.code === "Space"){
      e.preventDefault();
      if(started) togglePlay();
    }
  });

  // ==========================
  // INIT
  // ==========================
  buildTracksUI();
  syncLCD();
  meterLoop();
  lcdStep.textContent = "1";
})();
